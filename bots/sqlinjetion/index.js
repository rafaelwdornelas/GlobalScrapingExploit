require("events").EventEmitter.setMaxListeners = 0;
require("events").EventEmitter.defaultMaxListeners = 0;
const Spider = require("node-spider");
const request = require("request");
var unique = require("array-unique");
const global = require("../../src/functionsglobal");
const config = require("../../config.json");
const log = global.log;
var path = require("path");

CapturaNovo();

//Função de captura na para verificação de framework
async function CapturaNovo() {
    //Busca na API um array de dominios para verificação
    var dominio = await GET();
    //Verifica se a api retornou valores
    if (dominio.rows[0] != undefined) {
        //Loop para verificação de cada um dos dominios retornados pela API
        await asyncForEach(dominio.rows, async (value) => {
            await Verifica(value.domain, value.id);
            console.log("Finalizou", value.domain);
        });
        //Caso não tenha retornado dados da API
    } else {
        //Exibe no terminal a espera de um minuto para nova verificação
        console.log("Aguarda 1 Minuto");
        //Aguarda 1 minuto
        await global.sleep(60000);
    }
    //Chama a mesma função novamente para loop infinito
    console.log("fim global");
    CapturaNovo();
}

//função para loop async
async function asyncForEach(array, callback) {
    for (let index = 0; index < array.length; index++) {
        await callback(array[index], index, array);
    }
}

async function Verifica(urltemp, id) {
    return new Promise(async function (resolve, reject) {
        log("URL: www." + urltemp);
        //Monta o retorno com id e identidade
        var retorno = { id: id };
        //Retorna a API o resultado do framework encontrado no dominio
        POST(retorno);
        //Array de links para remover repetidos
        var mylinks = [];
        //Array de Emails para remover repetidos
        var myemails = [];

        var contagem = 0;

        var spider = new Spider({
            // How many requests can be run in parallel
            concurrent: 5,
            // How long to wait after each request
            delay: 500,
            // Re-visit visited URLs, false by default
            allowDuplicates: false,
            // If `true` all queued handlers will be try-catch'd, errors go to `error` callback
            catchErrors: true,
            // If `true` the spider will set the Referer header automatically on subsequent requests
            addReferrer: false,
            // If `true` adds the X-Requested-With:XMLHttpRequest header
            xhr: false,
            // If `true` adds the Connection:keep-alive header and forever option on request module
            keepAlive: false,
            // Called when there's an error, throw will be used if none is provided
            error: function (err, url) {},
            // Called when there are no more requests
            done: function () {
                resolve();
            },

            //- All options are passed to `request` module, for example:
            headers: {
                "user-agent":
                    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36",
            },
            encoding: "utf8",
        });

        var handleRequest = function (doc) {
            var body = doc.res.body;
            //Passa o valor da url para tratamento
            var urlx = doc.url;

            //Remove das string da url todos os amp;
            urlx = urlx.replace(/amp;/g, "");
            try {
                //Decode da URL
                urlx = decodeURIComponent(urlx);
            } catch (error) {
                log(urlx + ": " + error, 1);
            }

            //captura emails da página
            var emailsArray = [];

            try {
                emailsArray = body.match(
                    /[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+/g
                );
            } catch (error) {}

            //Verifica se retornou email
            if (emailsArray) {
                //Retira do array email repetidos
                emailsArray = unique(emailsArray);
                //verifica todos emails do array
                for (var i = 0; i < emailsArray.length; i++) {
                    //verifica se a url atual já foi salva
                    if (myemails.indexOf(emailsArray[i]) == -1) {
                        //Adiciona o email atual a lista de emails já obtidas
                        myemails.push(emailsArray[i]);
                        if (
                            emailsArray[i].endsWith(".gif") == false ||
                            emailsArray[i].endsWith(".jpg") == false ||
                            emailsArray[i].endsWith(".png") == false ||
                            emailsArray[i].endsWith(".jpeg") == false ||
                            emailsArray[i].endsWith(".") == false
                        ) {
                            log(emailsArray[i], 3);
                            //salva emails capturados com a página onde foram localizados
                            global.Savelogs(emailsArray[i], "SQLiMails");
                        }
                    }
                }
            }
            log(urlx, 1);
            //verifica se a url é passivel de sql injetion
            if (
                /(\?|\?&)([a-zA-Z]\w+|[a-zA-Z])=([a-zA-Z0-9])*/g.test(urlx) &&
                urlx.indexOf(";O=") == -1
            ) {
                //separa a url para verificar repetição
                var arr = urlx.split("=");

                //verifica se a url atual já foi salva
                if (mylinks.indexOf(arr[0]) == -1) {
                    //Exibe no terminal a url capturada
                    log(urlx, 3);
                    //Adiciona a url atual a lista de url já obtidas
                    mylinks.push(arr[0]);
                    //salva no log a url obtida
                    global.Savelogs(urlx, "SQLiLinks_ID");
                }
            } else if (/\/([0-9]\w+|[0-9])$/g.test(urlx)) {
                //separa a url para verificar repetição
                var arr = urlx.split("/");
                //verifica se a url atual já foi salva
                if (mylinks.indexOf(arr[arr.length - 2]) == -1) {
                    //Exibe no terminal a url capturada
                    log(urlx, 3);
                    //Adiciona a url atual a lista de url já obtidas
                    mylinks.push(arr[arr.length - 2]);
                    //salva no log a url obtida
                    global.Savelogs(urlx, "SQLiLinks_URL");
                }
            }

            doc.$("a").each(function (i, elem) {
                // do stuff with element
                var href = doc.$(elem).attr("href").split("#")[0];
                var url = doc.resolve(href);

                if (
                    path.extname(url) != ".jpg" &&
                    path.extname(url) != ".jpeg" &&
                    path.extname(url) != ".pdf" &&
                    path.extname(url) != ".css" &&
                    path.extname(url) != ".svg" &&
                    path.extname(url) != ".map" &&
                    path.extname(url) != ".png" &&
                    path.extname(url) != ".doc" &&
                    path.extname(url) != ".docx" &&
                    path.extname(url) != ".xls" &&
                    path.extname(url) != ".zip" &&
                    path.extname(url) != ".rar" &&
                    path.extname(url) != ".tar" &&
                    path.extname(url) != ".js" &&
                    path.extname(url) != ".htm" &&
                    path.extname(url) != ".shtml" &&
                    path.extname(url) != ".html" &&
                    url.indexOf(".htm") == -1 &&
                    url.indexOf(".html") == -1 &&
                    url.indexOf(".shtml") == -1
                ) {
                    if (
                        url.startsWith("http://" + urltemp) ||
                        url.startsWith("https://" + urltemp) ||
                        url.startsWith("http://www." + urltemp) ||
                        url.startsWith("https://www." + urltemp)
                    ) {
                        if (contagem < 250) {
                            contagem += 1;
                            spider.queue(encodeURI(url), handleRequest);
                        }
                    }
                }
            });
        };

        //Verifica protocolo
        await request(
            {
                method: "GET",
                uri: "https://" + urltemp,
                timeout: 4000,
                rejectUnauthorized: false,
                followRedirect: true,
                maxRedirects: 5,
                requestCert: true,
                agent: false,
                headers: {
                    "User-Agent":
                        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36",
                },
            },
            async function (error, response, body) {
                if (error) {
                    //console.log(error.code);
                    if (error.code == "ETIMEDOUT") {
                        resolve();
                    } else {
                        await spider.queue(
                            "http://www." + urltemp + "/",
                            handleRequest
                        );
                    }
                } else {
                    //console.log(response.statusCode);
                    if (response.statusCode == 500) {
                        await spider.queue(
                            "http://www." + urltemp + "/",
                            handleRequest
                        );
                    } else {
                        await spider.queue(
                            "https://www." + urltemp + "/",
                            handleRequest
                        );
                    }
                }
            }
        );
    });
}

async function GET() {
    return new Promise(async function (resolve, reject) {
        var options = {
            uri: config.Host_Externo + "/sqliget/br",
            method: "GET",
        };

        request(options, async function (error, response, body) {
            resolve(JSON.parse(body));
        });
    });
}

function POST(dados) {
    var options = {
        uri: config.Host_Externo + "/sqlipost",
        headers: {
            authorization: config.token,
        },
        method: "POST",
        json: { id: dados.id },
    };

    request(options, function (error, response, body) {
        //console.log(body);
    });
}
