const request = require('request')
const fs = require('fs')
const DomainSuffix = require("parse-domain");
const DNS = require('native-dns');
const LineByLineReader = require('line-by-line');
const cheerio = require('cheerio')

//Carrega o Nome do arquivo para leitura de linha por linha
lr = new LineByLineReader('listas/novo.txt'); //2017-08-23 < proximo

//Inicia a Leitura linha por linha
lr.on('line', async function (line) {

	//Pausa a leitura para a próxima linha 
	lr.pause();

	try {

		//Captura o suffixo da URL
		var suffix = await DomainSuffix(line)

		//Verifica se o formato do Dominio é válido
		if (suffix.tld.indexOf('.br') > -1) {

			//Exibe no Terminal a URL a ser verificada
			console.log('Verificando:', line)

			//Inicia função a Captura das informações
			await Captura(line)

		}

	} catch (e) {

		//Exibe no Terminal Erro
		console.log('Error', line, e)

	}

	//Solicita nova linha
	lr.resume();

});

//Retorno quando é finalizado o arquivo de URLS
lr.on('end', function () {

	//Informa no Terminal que o arquivo foi finalizado
	console.log('Arquivo Finalizado')

});

//Função que captura de informações de dominios
async function Captura(url) {

	//Inicia uma promise para aguardar todo processo
	return new Promise(async function (resolve, reject) {

		//Captura o IP do dominio
		var ips = await Checkondns(url)

		//Captura o suffixo da URL
		var suffix = await DomainSuffix(url)

		//verifica se o dominio tem IP válido retornado
		if (ips == false) {

			//Informa no Terminal que o Dominio não possui IP definido
			console.log(url, 'DNS OFF')

			try {

				//Salva em arquivo que os Sites sem IP definido
				Savelogs(JSON.stringify(url), 'Erros/DNS_OFF_' + suffix.tld)

			} catch (e) {

			}

			//Retorna a promise false
			resolve(false)

		} else {

			//Faz um request na URL para colher informações de Servidor
			request({
				method: 'GET',
				uri: "http://" + url,
				timeout: 10000,
				rejectUnauthorized: false,
				followRedirect: true,
				maxRedirects: 5,
				requestCert: true,
				agent: false,
				headers: {
					'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'
				}

			}, async function (error, response, body) {

				//Verifica se a Resposta possue Erro
				if (error) {

					//monta o retorno com apenas dominio e IP
					var retorno = {
						'Dominio': url,
						'IP': ips
					}

					//monta o retorno todas informações
					var retorno = {
						domain: url,
						ip: ips,
						active: false,
						server: undefined,
						poweredby: undefined,
						suffix: suffix.tld
					}

					//Adiciona no Banco de Dados
					AddDomain(retorno)

					//Informa no Terminal erro no Request
					console.log(retorno, 'ERROR')

					//Salva em arquivo que o site possui IP definido só que não retornou nada no request
					Savelogs(JSON.stringify(retorno), 'Erros/Server_OFF_' + suffix.tld)

					//Retorna a promise false
					resolve(false);

				} else { //Caso o request nao pussua Erro:

					//monta o retorno todas informações
					var retorno = {
						domain: url,
						ip: ips,
						active: true,
						server: response.headers.server,
						poweredby: response.headers['x-powered-by'],
						suffix: suffix.tld
					}

					//Adiciona no Banco de Dados
					AddDomain(retorno)

					//Informa no Terminal todas informações colhidas
					Savelogs(JSON.stringify(retorno), 'Validos/' + suffix.tld)

					//Informa no Terminal todas informações colhidas
					console.log(retorno)

					//Retorna a promise true
					resolve(true)
				}

			});
		}

	});
}

//Função para Captura de IP via DNS
async function Checkondns(url) {

	//Inicia uma promise para aguardar todo processo
	return new Promise(async function (resolve, reject) {

		//Informa como false o valor padrão do retorno
		var retorno = false;

		//Configura o Request ao DNS
		var question = DNS.Question({
			name: url,
			type: 'A',
		});

		//Inicia o Request ao DNS
		var req = DNS.Request({
			question: question,
			server: {
				address: '8.8.8.8',
				port: 53,
				type: 'udp'
			},
			timeout: 10000,
		});

		//Retorno de erro por tempo máximo do request
		req.on('timeout', function () {
			retorno = false
		});

		//Recebe as informações de IP do Dominio
		req.on('message', function (err, answer) {
			answer.answer.forEach(function (a) {
				if (a.address != undefined) {

					//Atera a variavel retorno de false para o IP correspondente
					retorno = a.address

					//Retorna a promise o IP
					resolve(a.address)
				}
			});
		});

		//Retorno do fim do Request ao DNS
		req.on('end', function () {

			//Retorna a promise o retorno
			resolve(retorno);

		});

		//Dá inicio a requesição ao DNS
		req.send();

	});
}

//Função para gravação de LOG com as variaveis de Texto + nome do arquivo
function Savelogs(textlog, name) {
	try {
		var logger = fs.createWriteStream('logs/' + name + '.txt', {
			flags: 'a' // 'a' means appending (old data will be preserved)
		});

		//Escreve Linha no Arquivo
		logger.write(textlog + '\r\n')

		logger.end()

	} catch (err) {

	}
}

//Função para Busca de IP já capturados pelo robo
function BuscaIP(IP) {
	//Inicia uma promise para aguardar todo processo
	return new Promise(async function (resolve, reject) {

		fs.readFile('logs/IPS.txt', function (err, data) {

			//Verifica Erro
			if (err) throw err;

			//Verifica se o numero do IP existe no arquivo
			if (data.indexOf(IP) >= 0) {

				//Retorna True
				resolve(true)

			} else {

				//Retorna False
				resolve(false)
			}

		});

	});

}

function AddDomain(dados) {
	var options = {
		uri: 'http://localhost:4000/adddomain',
		method: 'POST',
		json: {
			"domain": dados.domain,
			"ip": dados.ip,
			"active": dados.active,
			"server": dados.server,
			"poweredby": dados.poweredby,
			"suffix": dados.suffix
		}
	}

	request(options, function (error, response, body) {
		//console.log(body) 
	});
}

